[TOC]
# 前言
- 数据结构是用来存储数据的方式，不同数据结构存在的目的是为了便于执行某些特定的数据操作，例如查询，但最终目标都是便于取出对我们有价值的数据信息。  
- 数据结构的算法是指从不同的数据结构中操作数据的方法步骤，算法的优劣决定了对数据结构进行数据操作的效率。  
- 数据结构和算法都是在特定场景下、因为特定的数据、为了解决特定的问题所产生的高效解决方案。

# 一、底层结构

## 1. 数组(物理结构)
按照目前的定义，数组是一整块连续的内存地址，特点是**数据连续，支持快速随机访问**，通过数组开头地址加上偏移量就可以获取到任意元素的值。

>Q：为什么支持随机访问？为什么访问快速？
>A：随机访问是指访问一个中间元素时不需要经过前面的元素；访问快速的原因是知道头元素的位置，根据内存位置计算就可以得到目标的位置，时间复杂度O(1)，这里的“随机“我个人觉得描述地并不是很准确。

## 2. 链表(逻辑结构)
链表的物理结构与数组不同，由**离散的内存地址构建的存储结构**，每个元素不仅要存值，还要存下一个元素的地址，在不同链表中还可能需要记录其它信息。

# 二、上层结构
## 1. 线性表
线性表是指**只有一个开始元素**、**只有一个结束元素**，以及**除开始和结束外，每个元素都只有一个前驱和一个后继**的数据结构

线性表可以用数组或者链表来实现，用数组实现时需要申请一块指定大小的内存，而链表无需提前申请。用链表实现时有以下三种类型

- 单链表：结点只往后指
- 双向链表：结点往前往后都可以指
- 循环链表：尾结点指向头结点

**数组和链表的时间复杂度比较**

||查找|删除|插入|
|----|----|----|----|
|数组|O(1)|O(n)|O(n)|
|链表|O(n)|O(n)|O(1)|

> 吐槽：这里有个很有意思的点：链表的删除操作的时间复杂度是多少？如果仅仅考虑删除操作，那么时间复杂度应该是O(1)，但如果考虑删除前需要定位被删除的元素那么就需要先调用查找操作，所以时间复杂度变为$O(n) + O(1) = O(n) $

## 2. 栈(stack)
栈是一种受限的线性表，表的末端称为**栈顶**，表只允许**进栈**和**出栈**两种操作，也叫做**后进先出表(LIFO)**。栈对应的两个操作的时间复杂度均为O(1)。

**应用场景**

- 代码检查中的括号匹配
- 数学表达式计算
- 函数栈帧

## 3. 队列(queue)
队列也是一种受限的线性表，表的末端叫做**队尾**，首端叫做**队首**。队列只能从队尾插入，队首删除，即**入队(enqueue)**和(**出队(dequeue)**，所以队列也叫做**先进先出表(FIFO)**。

**应用场景**

- 异步通信

## 4. 树(tree)
>参考：[ 二叉搜索树(BST)与平衡二叉树(AVL树)专题](https://blog.csdn.net/DaveBobo/article/details/77603549)
参考：[二叉树遍历递归与迭代实现](https://zhuanlan.zhihu.com/p/56895993)

树是多个结点的集合，若非空，存在一个**根结点(root)**，根结点下有一个或多个子树，通过边连接。结点的上方结点称为**父结点**，结点的下方结点称为**子结点**，子结点之间互为**兄弟结点**， 树的最下方结点称为**叶子结点**，每个结点拥有的子结点数称为**度**。

树由类似链表中的结点连接形成，但跟链表不同的是，树中结点的可能会连接到多个结点，由于不知道子结点的数量，所以不能提前分配。一般单个结点存放**自身的值**、**第一个子结点**，以及**下一个兄弟结点**，然后延伸下去就可以存放整棵树的信息。

**应用场景**

- 文件目录系统
- 数据库

## 5、二叉树

树的任意结点至多包含两棵子树称为二叉树，由于最多两个子树。

**类型**

- 满二叉树：叶子结点都在同一层并且除叶子结点外的所有结点都有两个子结点。
- 完全二叉树：叶子结点在最后一层或者倒数第二层，结点编号与满二叉树一致，可以少几个结点

**性质**

1. 在非空二叉树中，第$h$层的结点总数不超过$2^{h-1}$
2. 深度为$h$的二叉树最多有$2^{h}-1$个结点，最少有$h$个结点
3. 对于任意一棵二叉树，如果其叶结点数为$N_0$，而度数为2的结点总数为$N_2$，则$N_0=N_2+1$
4. 具有$n$个结点的完全二叉树的深度为$h = \lfloor log_2n \rfloor +1$(向下取整)，原因是$n \leq 2^h - 1$

**证明推导性质**
1. 略过
2.  
$$
S_n = a_1+a_2+...+a_n \\
q*S_n = a_2+a_3+...+a_{n+1}
$$
  上下相减 
$$
S_n - q*S_n = a_1 - a_{n+1} \\
(1-q)S_n= a_1 - a_{n+1} \\
S_n= a_1* \frac{1 - q^n}{1-q}
$$

3. 假设度为1的结点数是$N_1$，那么对于任意二叉树所有结点数肯定由度为0、1、2三种类型的结点相加得到，如下  
$$
N = N_0 + N_1 + N_2
$$
  假设总的边数等于$E$，因为度为2的结点对应两条边，度为1的结点对应一条边，那么  
$$
E = 2 * N_2 + N_1
$$
  又因为每个结点对应一个边，除了根节点，所以  
$$
E =  N - 1 \\
2 * N_2 + N_1 = N - 1 \\
2 * N_2 + N_1 = N_0 + N_1 + N_2 - 1 \\
N_0 = N_2 + 1
$$
4. 深度为$h$完全二叉树的结点数大于深度为$h-1$的满二叉树，小于等于深度为$h$的满二叉树
$$
2^{(h-1)} - 1 < n \leq 2^{h} - 1 \\
h -1 < log_2n \leq h \\
h < log_2n + 1 \\
h = \lfloor log_2n \rfloor + 1
$$
### 5.1 二叉搜索树
二叉搜索树，Binary Search Tree(BST)，也叫做二叉查找树，是一种有序树。

**性质**  

1. 若任意结点的左子树不空，则左子树上所有结点的值均小于该结点的值
2. 若任意结点的右子树不空，则右子树上所有结点的值均大于该结点的值
3. 任意结点的左、右子树也分别为二叉搜索树
4. 没有键值相等的结点

**复杂度**
时间复杂度是由**树的高度**决定的，也就是$O(h)$。由于同样的数据在不同排列顺序下生成的二叉搜索树的高度是不一样的，所以无法根据结点数推导复杂度。


### 5.2 平衡二叉树
> 可视化：[VisuAlgo演示旋转过程](https://visualgo.net/zh/bst?slide=1) 
> 参考文章：[分步图解平衡二叉树的插入过程（Python实现）](https://blog.csdn.net/qq_34840129/article/details/80728186)

> 全称： 

平衡二叉树，Adelson-Velsky and Landis Tree(AVL)，是二叉搜索树的改进版，在保证有序的同时，保证树的高度始终平衡。**bf值**，即当前结点的左子树高度和右子树的高度之差，平衡二叉树在结点增删之后需要根据bf值来判断是否平衡。

**性质**  
1. 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1
2. 并且左右两个子树都是一棵平衡二叉树
3. 平衡二叉树必定是二叉搜索树

**复杂度**

对于有n个结点的二叉平衡树，时间复杂度为O($log_2(n)$)。插入和删除结点后平衡操作的时间复杂度也是$O(log_2N)$

### 5.3 哈夫曼树
>全称：HuffmanTree  

什么是哈夫曼树？首先了解**带权长度**，它是指每个结点的值乘以该结点到根结点的层数，该乘积称为该结点的带权长度，该结点的值也称为权值，而整棵树的带权长度就是所有叶子结点的带权长度之和。假设给定n个权值作为n个叶子结点构造出一个带权长度最小的二叉树，则称为哈夫曼树或最优二叉树。  

**性质**

1. 所有叶子结点的带权长度之和最小

### 5.4 红黑树
>参考文章：  [红黑树(一)之 原理和算法详细介绍 ](https://www.cnblogs.com/skywang12345/p/3245399.html)
参考文章： [30张图带你彻底理解红黑树](https://www.jianshu.com/p/e136ec79235c)

>全称：Red-Black Tree，简称：RB Tree

顾名思义，红黑树就是结点上拥有红色或者黑色颜色标注的树，除了颜色之外，红黑树有以下五种特性

**性质**

1. 每个结点要么是红色，要么是黑色
2. 根结点是黑色
3. 红色结点的子结点一定是黑色
4. 为空的叶子结点是黑色
5. 任意结点到自己下面的任意一个叶子结点都会经过一样数量的黑色结点数

第五个性质决定了红黑树是以**黑色结点**作为参考来保持平衡的二叉树

**复杂度**
红黑树本质上还是一颗平衡二叉树，所以搜索的时间复杂度也是O($log_2(n)$)。但是它优化了插入和删除的改动的复杂度，这点优于普通的平衡二叉树
> 但是到底好了多少呢？如何量化？

## 6、B类树

### 6.1 B树
> 参考：[B树、B+树详解](https://www.cnblogs.com/lianzhilei/p/11250589.html)
> 参考：[B-树中时间复杂推导](https://blog.csdn.net/tracefiow/article/details/106262687)
> 可视化：[B-Trees](https://www.cs.usfca.edu/~galles/visualization/BTree.html)

全称：B represent Balanced，平衡多路查找树
简称：B-Tree

B树是一种很“矮胖”的树，相较于平衡二叉树，在容纳相同结点的情况下，B树可以保持更低的高度。B树有两个重要的概念，

1. **B树的阶**，即B树的度，每个结点的拥有的子树最多等于$m$
1. **关键字(key)**，每个key可以等于一个数值，每个结点最多可以有$m-1$个key

一般二叉树的结点会有如下的基本结构
```
class Node:
    value = 1
    left_kid = None
    right_kid = None
```
而B树的结点，大概是这个意思 
```
class Node:
    keys = [1, 2, ..., m-1]
    kids = [p_1, p_2, ..., p_m]
```
对比就可以发现，B树的结点存放的值变多了，指向子树的指针也多了。关于B树为什么要这么设计，网上的说法是当存储的数据量超过内存时就只能将数据存放在磁盘上，而从磁盘上读取数据的速度很慢，因此需要尽可能减少读取的次数。可以这样简单的想，我们会每次读取一个结点，然后用这个结点的值与我们想要的值比较，然后才能决定取左子树还是右子树或者其他子树，然后决定之后才能进行下次读取，这样每层都要读取一次磁盘，故而减少高度才能减少读取次数。另外我看到一种说法，为了提升效率应该将关键词的数量设置为磁盘块的倍数，这样可以最好地利用读取的效率，我之前看操作系统也提到过每次读取磁盘以扇区为单位，每个扇区大小是512个字节，也就是假设每个关键字的值是4个字节，那么每个结点上的关键词应该设置为$n * 128$个，但实际上肯定比这个复杂，因为每个结点存放的东西不止值，还有子树的指针等等。

**性质**  

> 如果上来直接看B树的性质，可能会很迷惑，但如果看过它是如何保持平衡的就很好理解了

1. 如果根结点不是叶子结点，那么至少有两个子结点
2. 每个结点最多有m个子节点
3. 每个非叶子结点、非根结点、至少有$\lfloor m/2 \rfloor$个子结点
4. 所有叶子结点在同一高度
5. 每个结点的关键字数等于子结点数减一

**时间复杂度**
B树的查询时间复杂度是O($log_mn$)，空间复杂度是O($n$)。下面看看是如何推导出来的。  首先假设第$i$层有$m_i$个结点，每个结点有$n$个关键字，那么该层关键字总数应该等于
$$
N_i = n_1 + n_2 + ... + n_m
$$
那么第$i+1$层的结点总数，也就是第$i$层的子结点数量，根据性质5应该是
$$
m_{i+1}  = (n_1+1) + (n_2+1) + ... + (n_m+1) = n_1 + n_2 + ... + n_m + m_i
$$
因为第$i$层的关键字总数为$N_i$，那么就可以得到 
$$
m_{i+1} = N_i + m_i = N_i + (N_{i-1} + m_{i-1}) = N_i + N_{i-1} + ... + N_1 + m_1
$$
已知$m_1 = 1$，假设$i$层以及之上所有层关键字的和如下

$$
N_{i\_{total}} = N_1 + N_2 + ... + N_i
$$
那么我们就可以得到结点数和关键字数之间的关系是
$$
m_{i+1} = N_{i\_{total}} + 1
$$

根据性质2和性质3，我们知道每个结点的子结点数量在$\lfloor m/2 \rfloor$~$m$之间（这里$m$代表B树的阶）。先假设在理想情况下每个结点的子结点数量都是$m$，那么

$$
N_{i\_{total}} + 1 = m^{i} \\
i = log_m{(N_{i\_{total}} + 1})
$$
因为$N$实际上是个常数，所以可以简化为  
$$
i = log_mN
$$
这是最优的情况，如果是最差的情况  
$$
i = log_{\frac{m}{2}}N
$$
所以可以得到B树的高度跟存放的值之间关系是log级别的，这也意味着查询的速度是log级别的，注意上面的最优和最差都是指查询的key在树的最底层这种最差情况，如果key在根结点，那么时间复杂度就是O($1$)了。

### 6.2 B+树
参考：[B树和B+树的插入、删除图文详解](https://www.cnblogs.com/nullzx/p/8729425.html)  

B+树是B树的一种变体，那么首先来比较一下两者的区别。在B树中每个key对应的data其实是一起存放在结点中的，而B+中的结点只存放了key，所有的data都在叶子结点层

> 为什么有的说关键字的数量跟子树指针数一致？难道他们说的是其他的实现方式？

B+树的结点中key的数量比指向子树的指针数量数量少一，跟B树一致，同时没有在结点内保存每个key对应的data，那么当查询key时，需要继续找key对应子树，直到叶子层结点，那里才存着data的值。所以对于B+树来说，所有data的值都在叶子结点一层。  

上面的区别导致B+树的几个特点
- 每个结点不需要存放data，那么在同一个磁盘读取中，可以查询到的关键字就变多了，这样可以降低树的高度，一次判断的关键字变多了，也可以提升查询的效率
- 由于所有的data都放在叶子层，那么所有查询的时间复杂度都是$logN$，不存在O($1$)的最优情况，很稳定
- 还有一个特点是，B+树会在叶子结点之间维护横向指向的指针，从而构建出一个双向链表，便于执行区间查找

**复杂度**
B+树的时间复杂度跟B树一样，但在实践中性能优于B树，可以理解为B树的应用版


### 6.3 B\*树
B\*树，感觉资料很少，是B+树的变体，在非叶子结点和非根结点之间增加了横向连接的指针，据说是给定一个开始结点和一个目标结点，能够找到两者的最短路径，这确实更加像图了。

### 6.4 B树的前身
**2-3树和2-3-4树**
2-3树是指一个树中只有两种结点，一种有1个值和2个子节点，称为2结点，另一种有2个值和3个子节点，称为3结点。
2-3-4树也很好理解，就是在2-3树的基础上多了一个4结点，也就是有3个值和4个子节点的结点。  
怪不得很多人说B树的来源于这两种树，确实看起来B树就是做了m阶的扩展。

## 7. 图
参考：[数据结构：图](https://www.jianshu.com/p/bce71b2bdbc8)
参考：[动画解析：图的遍历方式有哪些？](https://www.cxyxiaowu.com/9854.html)

所谓图就是指多个互相连通的结点组成的数据结构。图有两种实现方式：邻接链表和邻接矩阵。完全图是指所有结点互相连接，根据累加公式可以推出完全图有$\frac{1}{2}n(n-1)$条边。根据图拥有的边的多少可以将图分为稀疏图和稠密图，前者适合链表实现，后者适合矩阵实现

```
# 矩阵
- b c
a - c
a b -

# 链表
a -> b -> c
b -> a -> c
c -> a -> b
```

## 8. 堆

参考：[数据结构：堆（Heap）](https://www.jianshu.com/p/6b526aa481b1)
参考：[堆的应用：如何快速获取到Top 10最热门的搜索关键词](https://shouliang.github.io/2018/11/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/29%20%7C%20%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%8E%B7%E5%8F%96%E5%88%B0Top%2010%E6%9C%80%E7%83%AD%E9%97%A8%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D/)
堆是用数组实现的完全二叉树，有两种类型：最大堆和最小堆。堆通过索引位置确定子结点和父结点。

**性质**
1. 最大堆父结点大于下面所有的子结点
2. 最小堆父结点小于下面所有的子结点
3. 堆只能是完全二叉树

**应用场景**

- 优先级队列
- top K
- 中位数、99%响应时间

## 9. 散列表
参考：[数据结构与算法——散列表](https://zhuanlan.zhihu.com/p/70477750)

散列表也是数组，然后通过特定的散列函数将key映射到数组的索引位置index上。由于数组的长度是有限的，而key的可能是无限的，所以总会有冲突，也就是不同的key映射到同个index上。散列表需要存储的元素个数跟散列表的大小的比值称为装填因子。

解决冲突：

- 链表法：每个数组索引存放一个链表的地址，映射到相同index的key都放在这个链表上
- 开发寻址法：
	- 线性探测法：通过某个线性哈希函数重新选一个可用位置，最差的情况，全部遍历一遍
	- 平方探测法：用一个二次方程来选址，避免线性探测法的聚集问题
	- 双散列：
	- 再散列：
- 可扩散列：

