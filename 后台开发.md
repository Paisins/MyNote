这篇总结目前还是很乱，待整理

**参考**
- [10张图带你了解后台服务架构演变](https://blog.csdn.net/chanql123/article/details/100103345)
- [从输入URL到页面加载发生了什么](https://segmentfault.com/a/1190000006879700)
- [Django 从启动到请求到响应全过程分析-入门版](https://juejin.cn/post/6844903768136351751)

## 一、开发流程
### 基础
#### 数据库
- 表设计：构建数据库表(sql)/数据库orm model
- 缓存数据库：redis配置
#### 配置
> (项目内存放/zookeeper远程)

- 数据库配置
- 日志配置
#### 代码结构设计
- 解耦合
#### 接口
- 定义api(自动生成接口文档)
## 二、开发技巧
### 1、本地缓存
``` python
class GetSetTer(object):
    def __init__(self):
        self._x = None

    @property
    def x(self):
        """I'm the 'x' property."""
        print("getter of x called")
        return self._x

    @x.setter
    def x(self, value):
        print("setter of x called")
        self._x = value

    @x.deleter
    def x(self):
        print("deleter of x called")
        del self._x
```
其实很简单的另一种方式就是放在`__init__.py`中
### 2、 独立服务
其实说白了就是当运行起后台服务后，需要单独启动某个服务，但与单独启动一个进程不同的是，这个服务一般依赖已启动的后台服务，也就是依赖其中已加载的对象，目前我还不能完全理解这部分如何实现的，需要理解下**contextlib**
```python
# 以fastapi为例
from fastapi import FastAPI
from work_wechat_robot import app
from contextlib import asynccontextmanager

@asynccontextmanager
async def app_context(app):
    """
    app上下文，一般用于脚本
    """
    assert isinstance(app, FastAPI)
    for func in app.router.on_startup:
        await func()

    try:
        yield app
    finally:
        for func in app.router.on_shutdown:
            await func()

async def work():
    async with app_context(app):
        await HandleDelayTask().run()

```
k8s可以实现

## 三、后台部署运维
- k8s
- zookeeper

##### 数据库
1、数据库迁移、维护、备份

##### 性能
1、QPS等其他衡量后台服务能力的参数

### 一、nginx

#### 1、我的理解
nginx的属性是一个web服务器，它的优点是可以处理高并发的情况

##### nginx为什么快？
Nginx 高性能、高并发：

Nginx 采用：多进程 + 异步非阻塞方式（IO 多路复用 epoll）
请求的完整过程：
建立连接
读取请求：解析请求
处理请求
响应请求
请求的完整过程，对应到底层，就是：读写 socket 事件

### ip过滤
新建conf，使用deny和allow，允许和屏蔽单个ip
或者location中规则匹配ip，将不符合的返回403

### 2、如何使用nginx

## 四、性能
### 1、QPS（query per second）
吐量（QPS）= 处理能力（CPU）/ 响应时间。
线程数 = 2 * CPU核数 + 1
总QPS = （1000ms/ 响应时间）* 线程数

## 其他概念
### RPC
RPC是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。

RPC：所谓的远程过程调用 (面向方法)
SOA：所谓的面向服务的架构(面向消息)
REST：所谓的 Representational state transfer (面向资源)

API只是一个实现方式，Web Service属于架构里的Web服务，RPC属于Web Service的一种使用方式。
Web Service：
从使用方式上，分为RPC，SOAP，REST；
从数据格式上，分为XML，JSON；

## 其他工具
### 1、接口文档
[swagger](https://editor.swagger.io/)：接口文档编写工具
不论使用哪种框架，尽量可以自动生成接口文档，避免每次修改，以及修改不及时导致问题

### 2、消息队列和异步框架
rabbitmq、celery

### 3、接口调试工具
postman

### 进程维护和代码整理
supervisor
fabric 

### 性能测试工具

## 安全
CSRF 攻击

## 业务经验
[线上故障如何快速排查？来看这套技巧大全](https://www.infoq.cn/article/qisvv7sfrsxmikhldvtw)

相对来说，网上讲python后台的比较少，但思路都差不多，之后找下对应的工具

一般来说，肯定是先看日志，包括后台服务本身的日志，以及控制后台的日志，假设日志没有，看一下三个

- 查看后台服务的进程和线程运行情况，关注利用率
- 查看数据库状况
- 查看服务器本身的性能

## 猜想
1、后台服务强约束条件，例如设置服务能力上限，一旦达到，就延缓后续请求，目标是不宕机

# 后端多人开发协同思考
**一般流程**
当需求确定后，首先是分配接口以及底层逻辑任务，每个人开始开发后，首先完成底层逻辑，然后写上层接口，由于各自写自己的，很容易出现几个问题
- 相同含义的参数名不统一
- 返回格式不统一，例如时间和数据类型
- 逻辑复写，由于代码未提交或者未沟通，一些底层功能已经有人写了
## 1、参数统一
考虑使用参数规范工具或者开发一个，希望能够展示当前全部参数，然后将类似的放在附近
## 2、返回不统一
写返回结果的格式以及注释，大部分后端应该是不想写这个部分，觉得只把结果丢给前端就可以
## 3、逻辑复写
还有一个可能的原因是每个人的解耦合的思想不一定一致，解耦的场景不一定一致，所以分离出来的函数会接受不同的参数，于是导致实现相同功能的底层有很多细微区别，其实这个不一定是坏事，实际上这个也不是不可以，但要具体情况具体讨论，如果想尽量避免这个问题，必须实现一个事情，那就是让代码放在它该放的位置，这就是代码设计的问题。

# 技术栈
## dsd后台开发
- 接口文档和数据表
- 搭建项目，设置访问端口
- 编写控制器和视图逻辑，包括数据库增删改查操作
- 日期与地区
- 权限验证
- 中间件
- 数据库连接池
- redis缓存
- 消息队列
- 日志管理（注意日志累积对服务器的影响）
- django自带的后台系统了解一下
- 参数校验

全局缓存对象
- 会话连接池
	- 限制连接数
	- timeout

# 理解/思考
##### 后台类型
不同服务对应的后台是不一样的吗？例如系统管理类型、影视频服务类型。这些对应的数据库存放格式是不一致的，为了满足服务需求，承受的访问压力、带宽、响应速度都是不一样的
##### 原子性
原子性，如何应对同时的数据修改、例如说锁的概念；虽然有保证数据原子性的方式，例如事务，但为什么大家都不使用？例如多条数据同时被修改，某些可能同时被修改的数据。
##### 后台基础工具
一个后台项目的快速搭建离不开完善的基础工具库，虽然目前开源已经很多，但总有一些地方需要根据当前的项目修改，因此刚开始开发的时候要注意将那些基础的工具整理出来作为工具包，例如常用的redis缓存代码，消息队列工具等等
##### 配置文件
- 最初配置文件放在项目内部
- 随着项目增多，多个项目可以有相同的配置，一个个修改比较麻烦，所以将配置做成一个服务，项目在启动时，去配置服务处根据一系列参数拿到对应的配置，这样可以一个配置文件可以同时对应多个项目修改方便，其次如果需要新增配置，可以在配置服务处新增，然后修改项目中的配置参数，逻辑清晰
- 上述默认多个项目会请求相同的配置，本质是多个项目依赖同一个服务，例如数据库，随着业务继续增大，一个业务对应的数据可能需要放在多个数据库，或者做分布式，这时就需要根据某些条件动态返回分配某个数据库作为配置返回给项目